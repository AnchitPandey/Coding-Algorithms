class Solution {
    
    public int bfs (int start, int[][] graph, int counter, Set<Integer> infected, HashMap<Integer,Integer> visited) {
        
        Queue<Integer> qu = new LinkedList();
        boolean ans = false;
        qu.add (start);        
        visited.put (start,0);
        while (!qu.isEmpty()){
            int curr =  qu.poll();
            counter+=1;
            if (infected.contains(curr)){
                if (curr != start){
                    ans = true;
                }    
            }
            for (int  i= 0; i< graph[curr].length;i+=1){
                //int child = graph[curr][i];
                if (graph[curr][i] ==0)
                    continue;
                if (!visited.containsKey(i))
                {
                    visited.put (i,0);
                    qu.add (i);
                }
            }
        }
        return ans == true ? 0: counter;
    }    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        Set<Integer> infected = new HashSet();
        for (int i=0; i< initial.length;i+=1)
            infected.add (initial[i]);
        HashMap<Integer, Integer> visited = new HashMap();
        for (int i =0 ; i< initial.length;i+=1)
        {
            if (!visited.containsKey (initial[i]))
            {
                int counter = bfs (initial[i], graph, 0, infected, visited);   
                visited.put (initial[i], counter);
            }           
        }
        //System.out.println(visited);
        int max = 0;
        for (Map.Entry<Integer,Integer> me: visited.entrySet()){
            max = Integer.max (max, me.getValue());
        }
        int ans = Integer.MAX_VALUE;
        for (Map.Entry<Integer,Integer> me: visited.entrySet()){
            
            if (me.getValue() == max && infected.contains(me.getKey()))
            {
                ans = Integer.min (ans, me.getKey());
            }
        }
        return ans;
    }
}
